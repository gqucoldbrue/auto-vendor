import { CssVarOptions, CssVar } from '@pandacss/shared';
import { Tokens, SemanticTokens } from '@pandacss/types';

type TokenStatus = 'deprecated' | 'experimental' | 'new';
interface ExtensionData {
    status?: TokenStatus;
    category?: string;
    references?: TokenReferences;
    condition?: string;
    conditions?: TokenConditions;
}
interface TokenConditions {
    [key: string]: string;
}
interface TokenReferences {
    [key: string]: Token;
}
type TokenExtensions<T = {}> = ExtensionData & {
    [key: string]: any;
} & T;
interface ExtendedToken {
    name: string;
    value: any;
    type?: string;
    path?: string[];
    description?: string;
    extensions?: TokenExtensions;
}
/**
 * Represents a design token in the dictionary
 */
declare class Token {
    name: string;
    value: any;
    originalValue: any;
    path: string[];
    type?: string;
    description?: string;
    extensions: TokenExtensions;
    constructor(data: ExtendedToken);
    /**
     * The unique identifier of the token.
     */
    get id(): string;
    /**
     * Whether the token is a conditional token.
     * Conditional tokens are tokens that have multiple values based on a condition.
     */
    get isConditional(): boolean;
    /**
     * Whether the token has a reference in its value.
     * e.g. {color.gray.100}
     */
    get hasReference(): boolean;
    /**
     * Whether the token is a complex or composite token.
     */
    get isComposite(): boolean;
    /**
     * Returns the token value with the references expanded.
     * e.g. {color.gray.100} => var(--colors-gray-100)
     *
     */
    expandReferences(): string;
    /**
     * Whether this token has a reference to another token
     */
    get isReference(): boolean;
    /**
     * Returns the list of references in the token value
     */
    get references(): string[];
    clone(): Token;
    /**
     * Returns an array of tokens per conditions.
     * It is commonly used in semantic tokens, and can have multiple values based on a condition.
     * e.g. primary: { light: '#000', dark: '#fff' }
     */
    getConditionTokens(): Token[] | undefined;
    /**
     * Add more extensions to the token
     */
    setExtensions(extensions: TokenExtensions): this;
    setType(): void;
}

type EnforcePhase = 'pre' | 'post';
interface TokenTransformer {
    name: string;
    enforce?: EnforcePhase;
    type?: 'value' | 'name' | 'extensions';
    match?: (token: Token) => boolean;
    transform: (token: Token, dictionary: TokenDictionary) => any;
}
interface TokenDictionaryOptions {
    tokens?: Tokens;
    semanticTokens?: SemanticTokens;
    breakpoints?: Record<string, string>;
    prefix?: string;
    hash?: boolean;
}
interface TokenMiddleware {
    enforce?: EnforcePhase;
    transform: (dict: TokenDictionary) => void;
}
declare class TokenDictionary {
    private options;
    allTokens: Token[];
    byName: Map<string, Token>;
    constructor(options: TokenDictionaryOptions);
    init(): this;
    get prefix(): string | undefined;
    get hash(): boolean | undefined;
    getByName: (path: string) => Token | undefined;
    formatTokenName: (path: string[]) => string;
    formatCssVar: (path: string[], options: CssVarOptions) => CssVar;
    registerTokens(): this;
    registerToken: (token: Token, transformPhase?: 'pre' | 'post') => void;
    private transforms;
    registerTransform(...transforms: TokenTransformer[]): this;
    private execTransform;
    execTransformOnToken(transform: TokenTransformer, token: Token): void;
    transformTokens(enforce: EnforcePhase): this;
    private middlewares;
    registerMiddleware(...middlewares: TokenMiddleware[]): this;
    applyMiddlewares(enforce: EnforcePhase): void;
    getReferences(value: string): Token[];
    usesReference(value: any): boolean;
    addReferences(): this;
    filter(pattern: Partial<Token> | ((token: Token) => boolean)): Token[];
    addConditionalTokens(): this;
    expandTokenReferences(): this;
    colorMix: (value: string, tokenFn: (path: string) => string) => {
        invalid: boolean;
        value: string;
        color?: undefined;
    } | {
        invalid: boolean;
        color: string;
        value: string;
    };
    /**
     * Expand token references to their CSS variable
     */
    expandReferenceInValue(value: string): string;
    /**
     * Resolve token references to their actual raw value
     */
    resolveReference(value: string): string;
    build(): this;
    get isEmpty(): boolean;
    view: ReturnType<TokenDictionaryView['getTokensView']>;
    setComputedView(): this;
}
declare class TokenDictionaryView {
    private dictionary;
    constructor(dictionary: TokenDictionary);
    getTokensView(): {
        conditionMap: Map<string, Set<Token>>;
        categoryMap: Map<string, Map<string, Token>>;
        colorPalettes: Map<string, Map<string, string>>;
        vars: Map<string, Map<string, string>>;
        values: Map<string, string>;
        json: Record<string, Record<string, string>>;
        get: (path: string, fallback?: string | number) => string;
        getCategoryValues: (category: string) => Record<string, string> | undefined;
    };
    private processCondition;
    private processColorPalette;
    private processCategory;
    private processValue;
    private processVars;
}

export { Token, TokenDictionary };
